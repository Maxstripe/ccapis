--[[
    JAM - Just Another Miner - 2013 Sangar

    This program is licensed under the MIT license.
    http://opensource.org/licenses/mit-license.php

    This program is intended to run on turtles working in a very specific
    environment, to collaboratively (optional) dig up blocks of interest in a
    designated area. Yes, it's a mining program ;)

    Features:
      - Fully resumable, thanks to LAMA and my state API. This resume is *very*
        stable. It even survived multiple game crashes (out of memory).
      - Interactively configurable (quarry size, torch placement).
      - Supports turtles cooperatively working on the same quarry, up to the
        total number of holes being dug - one turtle per hole, max. If there's
        fewer turtles than holes, the holes will be worked on sequentially.
      - Adding new turtles is super-easy, just place them into the dock, facing
        the fuel chest (away from the disk drive) and the environment will be
        installed on it and executed.

    To get started, set up the docking station like this (top-down view).

         CF       Where: CD = Chest for dropping found blocks.
      CD TU CT           CF = Chest with fuel.
         DD              CT = Chest with torches (only needed when used).
                         DD = A disk drive with an empty floppy inside.
                         TU = A turtle, looking at the fuel chest.

    Make sure the turtle in the middle is facing the fuel chest, then install
    the environment like this:
        > pastebin get h9KJ4DRt jam-install
        > jam-install

    The program will guide you through the next steps. Always make sure there's
    enough fuel (and if used, torches) in the chests, and empty the dropbox
    regularly!

    To add more turtles to an existing quarry, simply place them into the
    docking station like you did the first turtle, i.e. facing the fuel chest.
    It will automatically be configured by the program written onto the floppy
    disk when the quarry was set up and then run this program.
]]

assert(os.loadAPI("apis/bapil"))
assert(os.loadAPI("apis/logger"))
assert(os.loadAPI("apis/startup"))
assert(os.loadAPI("apis/state"))
assert(os.loadAPI("apis/lama"))

-------------------------------------------------------------------------------
-- Semi-config (you normally won't want to touch these)                      --
-------------------------------------------------------------------------------

-- The channel on which we'll send out status messages.
local sendChannel = 10113

-- Whether to write our progress into a log file (each time the program changes
-- its state it would log that). This is primarily intended for debugging.
local writeLog = false

-- File in which to store current program state on the turtle, for resuming the
-- program after a reboot.
local stateFile = "/.jam-state"

-- The path to the file on the disk drive which we use to track how many jobs
-- we have already assigned to turtles. Note that this will be prefixed with
-- the disk drives mount path, so it should be a relative path.
local jobFile = ".jobs"

-- Given the turtle is in it's native orientation, this is the side the chest
-- we drop stuff we found into.
local dropSide = lama.side.left

-- Given the turtle is in it's native orientation, this is the side the chest
-- we can get fuel from.
local fuelSide = lama.side.front

-- Given the turtle is in it's native orientation, this is the side the chest
-- we can get new torches from.
local torchSide = lama.side.right

-- Given the turtle is in it's native orientation, this is the side the floppy
-- disk drive we use to track job progress on is at.
local diskSide = lama.side.back

-------------------------------------------------------------------------------
-- Internal variables / constants                                            --
-------------------------------------------------------------------------------

-- Do not change the next two variables, lest they interfere with the interval
-- of blocks to ignore! They is just here to make the code more readable (no
-- magic numbers all over the place.)

-- A slot that we can assume to be empty, used for temporary stuff, in
-- particular when refueling or picking up torches.
local tempSlot = 15

-- The slot number in which we keep our torches.
local torchSlot = 16

-- Same as diskSide but using redstone.getSides() constants (for disk API).
local rsDiskSide = ({[lama.side.forward] = "front",
                     [lama.side.right]   = "right",
                     [lama.side.back]    = "back",
                     [lama.side.left]    = "left"})[diskSide]

-- The log we use. Print to screen if we're not supposed to log stuff.
local log = writeLog and logger.new("jam") or
            {info = function(_, fmt, ...)
                        print("[INFO] " .. string.format(fmt, ...))
                    end,
             warn = function(_, fmt, ...)
                        print("[WARNING] " .. string.format(fmt, ...))
                    end}

-- Forward declaration of namespaces.
local private

-------------------------------------------------------------------------------
-- Program states                                                            --
-------------------------------------------------------------------------------

-- Start assembling our state machine.
local program = state.new(stateFile)

--[[
    This state is purely used for interactively setting up a dig site. It asks
    the user a couple of questions, prepares the disk drive and then reboots
    into the actual worker loop.
]]
:add("setup", function()
    -- Make sure there's a disk drive behind us.
    assert(disk.isPresent(rsDiskSide),
        "Bad setup detected, no disk in disk drive found.")
    local diskPath = disk.getMountPath(rsDiskSide)

    -- Configure the turtle to use our local coordinate system.
    lama.set(0, 0, 0, lama.side.north)

    -- If there's no job file on the disk drive we're starting from scratch.
    local jobFile = fs.combine(diskPath, jobFile)
    assert(not fs.exists(jobFile) or not fs.isDir(jobFile),
        "Bad disk, folder at job file location.")
    if not fs.exists(jobFile) then
        local jobCount, placeTorches, placeIgnored, haveIgnoreChest =
            private.setupDigSite()
        if jobCount == nil then
            -- nil is the abort signal, restart the state.
            return
        end

        -- Check for chests.
        print("Checking for chests...")
        lama.turn(dropSide)
        assert(turtle.detect(),
            "Bad setup detected, no drop chest found.")
        lama.turn(fuelSide)
        assert(turtle.detect(),
            "Bad setup detected, no fuel chest found.")
        if placeTorches or haveIgnoreChest then
            lama.turn(torchSide)
            assert(turtle.detect(),
                "Bad setup detected, no torch/ignored blocks chest found.")
        end
        lama.turn((diskSide + 2) % 4)

        -- Ask for ignored blocks in ignore chest before getting started.
        if haveIgnoreChest then
            term.clear()
            term.setCursorPos(1, 1)
            print("Please put as many of each block type \n" ..
                  "that you want to avoid into the torch \n" ..
                  "chest as you wish to employ turtles.  \n" ..
                  "(For example: one stack each)       \n\n" ..
                  "When done, press [Enter] to confirm.\n\n" ..
                  "Recommended: Stone, Dirt and possibly \n" ..
                  "Gravel or Sand (depends on the biome).\n" ..
                  (placeIgnored and
                  "You may also want to add Cobblestone, \n" ..
                  "to allow placing it while moving up."
                  or "" ))
            private.prompt({keys.enter}, {})
        end

        -- If all went well, write the job file to the disk so that all turtles
        -- placed into the dock from now on will be initialized automatically.
        term.clear()
        term.setCursorPos(1, 1)
        print("Writing settings to disk... ")
        local file = fs.open(jobFile, "w")
        assert(file, "Could not open job file for writing.")
        file.write(textutils.serialize({totalJobs = jobCount,
                                        placeTorches = placeTorches,
                                        placeIgnored = placeIgnored,
                                        haveIgnoreChest = haveIgnoreChest}))
        file.close()
    end

    -- Next up: add this turtle as a worker to the quarry.
    switchTo("add_turtle")

    -- Finish initialization via disk startup. For example, this will install
    -- this program as an autorun script.
    os.reboot()
end)

--[[
    Given an existing dig site adds a new turtle to work on it.
]]
:add("add_turtle", function()
    -- Align back to face away from the disk drive.
    lama.turn((diskSide + 2) % 4)

    -- Copy global quarry settings.
    local diskPath = disk.getMountPath(rsDiskSide)
    local jobFile = fs.combine(diskPath, jobFile)

    local file = fs.open(jobFile, "r")
    assert(file, "Bad disk, could not find job file.")
    local jobData = textutils.unserialize(file.readAll())
    assert(type(jobData) == "table", "Bad disk, invalid job data.")
    file.close()

    placeIgnored = placeIgnored or jobData.placeIgnored
    placeTorches = placeTorches or jobData.placeTorches
    haveIgnoreChest = haveIgnoreChest or jobData.haveIgnoreChest

    -- Ask for the blocks to ignore to be placed in our inventory. Remember how
    -- many block types we're supposed to ignore. If we got nothing (nil) we're
    -- supposed to try again.
    if haveIgnoreChest then
        ignoreCount = private.setupIgnoredBlocksFromIgnoreChest(placeTorches)
    else
        ignoreCount = private.setupIgnoredBlocks(placeTorches)
        if not ignoreCount then
            return
        end
    end

    -- Drop any duplicates we have of the stuff we're supposed to ignore.
    switchTo("goto_drop") -- Equivalent to drop, but more uniform flow.
end)

--[[
    Go back to the docking station to drop stuff we picked up.
]]
:add("goto_drop", function()
    log:info("Going home to deliver the goods.")
    private.sendMessage("state", "goto_drop")

    -- Put any 'ignored' blocks we dig up while going home into the first four
    -- slots, if possible (by having the first one selected while moving).
    turtle.select(1)
    -- Player being invulnerable can block this, so we have to keep trying.
    repeat
        local x, y, z = lama.get()
        local path = private.generatePath(x, y, z, 0, 0, 0, "home")
    until lama.navigate(path, math.huge, true)
    switchTo("drop")
end)

--[[
    Actually drop anything in our inventory that's surplus.
]]
:add("drop", function()
    log:info("Dropping it!")
    private.sendMessage("state", "drop")

    -- Drop any surplus of the blocks we're supposed to ignore. We may have
    -- gotten some when digging down. Hold on to that stuff if we're not yet
    -- done with our job, so we still have a chance to place them while moving
    -- up again.
    if not placeIgnored or not job then
        for slot = 1, ignoreCount do
            if turtle.getItemCount(slot) > 1 then
                private.drop(slot, 1)
            end
        end
    end

    -- Drop all the items we actually found.
    for slot = ignoreCount + 1, 16 do
        if not placeTorches or slot ~= torchSlot then
            -- Make sure it's not a stack of ignored blocks we use to fill our
            -- hole back up.
            local skip = false
            if ignoredLookup then
                for i = 1, #ignoredLookup do
                    if ignoredLookup[i] == slot then
                        skip = true
                        break
                    end
                end
            end
            if not skip then
                private.drop(slot)
            end
        end
    end

    -- Continue with our current job, or get a new one if we don't have one.
    if job then
        switchTo("refuel_job")
    else
        switchTo("get_job")
    end
end)

--[[
    Tries to get a job, on success refuels and executes it, otherwise refuels
    to move to retirement position (out of the way of other turtles).
]]
:add("get_job", function()
    log:info("Looking for a new job.")
    private.sendMessage("state", "get_job")

    -- Make sure the disk drive is behind us.
    lama.turn((diskSide + 2) % 4)

    -- Wait a bit to finish moving and connect to the disk drive. This is
    -- really weird, but apparently a disk drive can be 'present' before it is
    -- mounted. So we wait until it's actually mounted... damn timining
    -- problems. We limit our number of tries, in case the disk drive was
    -- removed or - by some *very* slim chance - we're not in the right spot.
    -- Try for a total of five seconds, so lag is a non-issue.
    for i = 1, 50 do
        if disk.isPresent(rsDiskSide) and disk.getMountPath(rsDiskSide) then
            break
        end
        os.sleep(0.1)
    end
    assert(disk.isPresent(rsDiskSide) and disk.getMountPath(rsDiskSide),
        "Bad setup detected, no disk in disk drive behind me!")

    -- Get the current job information.
    local diskPath = disk.getMountPath(rsDiskSide)
    local jobFile = fs.combine(diskPath, jobFile)

    local file = fs.open(jobFile, "r")
    assert(file, "Bad disk, could not find job file.")
    local jobData = textutils.unserialize(file.readAll())
    assert(type(jobData) == "table", "Bad disk, invalid job data.")
    file.close()

    local nextJob = jobData.nextJob or 1
    if nextJob <= jobData.totalJobs then
        job = nextJob
        jobData.nextJob = job + 1
        switchTo("refuel_job")
        log:info("Got one! Our new job ticket is #%d.", job)
        private.sendMessage("job", job)
    else
        endSlot = jobData.finished or 0
        jobData.finished = endSlot + 1
        switchTo("refuel_end")
    end

    file = fs.open(jobFile, "w")
    file.write(textutils.serialize(jobData))
    file.close()
end)

--[[
    Gets enough fuel to get to and back from our job.
]]
:add("refuel_job", function()
    log:info("Getting enough fuel to make it to our job and back.")
    private.sendMessage("state", "refuel_job")
    private.refuel(private.computeExpeditionCost(job))
    switchTo("restock_torches")
end)

--[[
    Refills our torch stack.
]]
:add("restock_torches", function()
    if placeTorches then
        log:info("Picking up some torches to bring light into the dark.")
        private.sendMessage("state", "restock_torches")
        private.restockTorches()
    end
    switchTo("goto_job")
end)

--[[
    Moves the turtle to the top of the hole it should dig.
]]
:add("goto_job", function()
    local tx, tz = private.computeCoordinates(job)
    log:info("On my way to my workplace @ (%d, %d)!", tx, tz)
    private.sendMessage("state", "goto_job")

    -- Put any ignored blocks into the first four slots.
    turtle.select(1)
    -- Player being invulnerable can block this, so we have to keep trying.
    repeat
        local x, y, z = lama.get()
        local path = private.generatePath(x, y, z, tx, -1, tz, "job")
    until lama.navigate(path, math.huge, true)

    if resumeDigUp then
        switchTo("dig_up")
    else
        switchTo("dig_down")
    end
end)

--[[
    Digs a hole down until we hit bedrock, returns to drop stuff if full and
    returns to where we left off.
]]
:add("dig_down", function()
    log:info("Looking for bedrock, can offer dancing skills.")
    private.sendMessage("state", "dig_down")

    -- Move back to where we stopped in case we had a full inventory.
    turtle.select(1)
    if resumeDigDown then
        log:info("Resuming from where a took a break.")
        while lama.getY() > resumeDigDown do
            lama.down(math.huge, true)
        end
        resumeDigDown = nil
    end

    -- Dig until we hit bedrock.
    repeat
        if not dropped or not dropped.gotSome then
            -- Go down a bit slower to build up our block sampling on the way
            -- if this is the first hole we're digging. For the remaining ones
            -- it should be good enough to look at the walls while moving up
            -- again, which we do anyway.
            local ignored = private.shouldIgnore(
                ignoreCount, turtle.detectDown, turtle.compareDown)
            if ignored and type(ignored) == "number" then
                dropped = dropped or {}
                dropped[ignored] = (dropped[ignored] or 0) + 1
                save()
            end
            turtle.select(1)
        end
        local brokeStuff = private.suckAndDig(turtle.suckDown, turtle.digDown)
        -- Try to move down if we don't break anything while doing so, because
        -- if brokeStuff returned false even though there is something it means
        -- our inventory is full and we should go empty it.
        local couldMove, whyNot = false
        if brokeStuff or not turtle.detectDown() then
            -- We either broke something or there's nothing there. Try to move
            -- down until we can. If we're blocked by an invulnerable entity it
            -- is most likely to be the player entity, so we wait for it to
            -- move away.
            repeat
                couldMove, whyNot = lama.down(math.huge, true)
            until couldMove or whyNot ~= lama.reason.invulnerable_entity
        end
    until not brokeStuff and not couldMove

    -- Check our inventory. If it's full we have to go empty it out, then come
    -- back to resume at this layer.
    if private.isInventoryFull() then
        resumeDigDown = lama.getY()
        switchTo("goto_drop")
    else
        -- If our inventory isn't full this means we hit the floor. Proceed
        -- with the next step of sorting our ignored block by frequency.
        lama.turn(lama.side.north)
        if dropped then
            -- Remember we don't have to sample while moving down anymore.
            dropped.gotSome = true
        end
        switchTo("sort_ignore")
    end
end)

--[[
    Sorts the blocks we're supposed to ignore, if any, so that the most
    frequently encountered ones are at the lower inventory positions (for
    faster early exists when comparing).
]]
:add("sort_ignore", function()
    log:info("Sorting blocks to ignore for improved lookup speed.")
    private.sendMessage("state", "sort_ignore")

    -- See if there's anything to sort at all.
    if ignoreCount > 1 then
        -- If we were interrupted while swapping items, restore our continuous
        -- list of blocks to ignore, then start over.
        while undo and #undo > 0 do
            local swap = table.remove(undo)
            turtle.select(swap[1])
            turtle.transferTo(swap[2])
            save()
        end
        undo = nil
        save()

        -- Get the total number of samples we got of the block type in that
        -- slot, based on what we've seen across our active time.
        local function getCount(slot)
            return dropped and dropped[slot] or 0
        end

        -- Undo logic: we build a list of reverse inventory transfers. This
        -- is fine because even if a transfer wasn't successful across the
        -- reboot, the reverse operation simply won't do anything at all.
        local function pushUndo(slotA, slotB)
            undo = undo or {}
            table.insert(undo, {slotA, slotB})
            save()
        end

        -- Swaps two slots in the inventory, while keeping an undo log to
        -- restore our state if we're shut down while we're at it (to avoid
        -- getting our list with additional samples getting out of sync).
        local function swap(slotA, slotB)
            -- If the slots are identical there's nothing to do, we'd just move
            -- the object to our temp slot and back again.
            if getCount(slotA) == getCount(slotB) then
                return
            end

            -- Happy rotating that can get terribly interrupted!
            turtle.select(slotA)
            pushUndo(tempSlot, slotA)
            turtle.transferTo(tempSlot)
            turtle.select(slotB)
            pushUndo(slotA, slotB)
            turtle.transferTo(slotA)
            turtle.select(tempSlot)
            pushUndo(slotB, slotA)
            turtle.transferTo(slotB)

            -- We're done! Clear our undo log and update the order of our
            -- sample list.
            undo = nil
            if dropped then
                dropped[slotA], dropped[slotB] = dropped[slotB], dropped[slotA]
            end
            save()
        end

        -- Get the list of entry indices so that we can sort it based on the
        -- sample counts for the respective block types.
        local entries = {}
        for slot = 1, ignoreCount do
            table.insert(entries, slot)
        end
        table.sort(entries, function(a, b)
                                return getCount(a) > getCount(b)
                            end)

        -- Reorder the inventory so that the block types with more samples are
        -- closer to the start of the inventory.
        for target = 1, #entries do
            local source = entries[target]
            swap(source, target)
            -- Update entry for the element we replaced (or rather: set its
            -- target entry to its new location).
            for i = 1, #entries do
                if entries[i] == target then
                    entries[i] = source
                    break
                end
            end
        end
    end

    -- Build a look-up table of slots that also contain ignored items in case
    -- we dug up so many we had an overflow. This is used for quickly knowing
    -- which slot to select for placing ignored blocks while moving up.
    if placeIgnored then
        ignoredLookup, placeIgnoredRequired = private.rebuildIgnoreCache(
            ignoreCount, ignoredLookup, placeTorches)
    end

    switchTo("dig_up")
end)

--[[
    Digs back up, picking up whatever isn't ignored. Returns home to drop
    stuff if inventory is full to resume where it we off.
]]
:add("dig_up", function()
    log:info("Digging back up, looking for valuables.")
    private.sendMessage("state", "dig_up")

    assert(ignoreCount, "Bad setup, don't know how many blocks to ignore.")

    -- If we stopped somewhere on the way to empty our inventory move back to
    -- that level and also restore the orientation to make sure we complete the
    -- level we were previously at.
    if resumeDigUp then
        log:info("Getting back to where I took a break.")
        local x, y, z, f = unpack(resumeDigUp)
        repeat until lama.moveto(x, y, z, f, math.huge, true)
        resumeDigUp = nil
    end

    -- We were interrupted while digging up a block we should normally ignored,
    -- but we wanted to get to fully fill up our hole. If there was an overflow
    -- this may have led to a new slot being used for the block, so we have to
    -- rebuild our cache of ignored blocks.
    if diggingAnIgnoredBlock then
        ignoredLookup, placeIgnoredRequired = private.rebuildIgnoreCache(
            ignoreCount, ignoredLookup, placeTorches)
        diggingAnIgnoredBlock = nil
        save()
    end

    -- Move up until we're back at our starting location (at level -1).
    while lama.getY() < -1 do
        -- Dig all four adjacent blocks on the current level. We always start
        -- a level facing north, so if we turn in this loop we can stop when
        -- we're facing north again.
        repeat
            -- See if we're ignoring that block. If we are, remember we found
            -- one more of that type (to increase our sample size), otherwise
            -- try to dig it out.
            local ignored = private.shouldIgnore(
                ignoreCount, turtle.detect, turtle.compare)
            local weShouldDigItAnyway = false
            if ignored then
                -- If ignored is set but not a number it means we're facing air
                -- so we can skip this part. Otherwise remember what it was.
                if type(ignored) == "number" then
                    dropped = dropped or {}
                    dropped[ignored] = (dropped[ignored] or 0) + 1
                    save()

                    -- If we still need some blocks to fill up the hole we
                    -- dug let's ignore that we should ignore this block and
                    -- dig it up anyway!
                    if placeIgnoredRequired and placeIgnoredRequired > 0 then
                        weShouldDigItAnyway = true
                        placeIgnoredRequired = placeIgnoredRequired - 1
                    end

                    -- Clear the variable to save space if we're done.
                    if placeIgnoredRequired and placeIgnoredRequired < 1 then
                        placeIgnoredRequired = nil
                    end
                end
            end

            if not ignored then
                -- Nope, not ignoring that one, reset our inventory position
                -- after checking to make sure we stack what can be stacked.
                turtle.select(ignoreCount + 1)
                private.suckAndDig(turtle.suck, turtle.dig)
            elseif weShouldDigItAnyway then
                -- Coming here means we want to get more ignored blocks to fill
                -- up the hole we dug. In that case make sure that if we start
                -- a new stack we keep track of it in our lookup table.
                local emptySlotsBeforeDigging = {}
                for slot = ignoreCount + 1, 16 do
                    if not placeTorches or slot ~= torchSlot then
                        if turtle.getItemCount(slot) == 0 then
                            emptySlotsBeforeDigging[slot] = true
                        end
                    end
                end

                -- Add to basic stacks if possible.
                turtle.select(1)

                -- Set our state so that we know what we were doing when
                -- resuming, because in that case we have to rebuild our lookup
                -- table (because we can't be sure the block was dug up into a
                -- not yet occupied slot).
                diggingAnIgnoredBlock = true
                save()

                -- If we're supposed to ignore this, it means we don't need to
                -- suck, because if we ignore chests we really don't want their
                -- inventories, either!
                turtle.dig()

                -- Check for newly used slots. If there is one it means that
                -- this block should be ignored.
                for slot, _ in pairs(emptySlotsBeforeDigging) do
                    if turtle.getItemCount(slot) > 0 then
                        -- Got a new slot!
                        ignoredLookup = ignoredLookup or {}
                        table.insert(ignoredLookup, slot)
                    end
                end
                diggingAnIgnoredBlock = false
                save()
            end

            -- See if we have to go empty our inventory. Remember our depth and
            -- facing to fully restore our state and finish digging out the
            -- level we're currently on.
            if private.isInventoryFull() then
                resumeDigUp = {lama.get()}
                return switchTo("goto_drop")
            end

            -- Next side, stop when we come full turn.
            lama.turnRight()
        until lama.getFacing() == lama.side.north

        -- Can only be blocked by a player, so we just try until it works.
        repeat until lama.up(math.huge, true)

        -- placeIgnored and placeTorches are mutually exclusive.
        if placeIgnored then
            -- Try to get rid of the blocks we're supposed to ignore but had to
            -- pick up while digging down. Figure out from which slot to place.
            local slot
            if ignoredLookup then
                -- The table is guaranteed to not be empty because we only
                -- remove entries below, after the actual placement, and
                -- set it to nil if it's empty at that point.
                -- The slot we select may be empty if and only if we were
                -- interrupted while placing the block the first time
                -- around. This makes the turtle.placeDown() a no-op which
                -- is not a problem.
                slot = ignoredLookup[#ignoredLookup]
            else
                -- No more lookup-blocks. Draw from our reference stacks.
                for i = 1, ignoreCount do
                    -- Keep at least one of our reference blocks.
                    if turtle.getItemCount(i) > 1 then
                        slot = i
                        break
                    end
                end
            end

            -- If we have a slot, place a block. It even rhymes!
            if slot then
                turtle.select(slot)
                turtle.placeDown()
                -- Update lookup table if we emptied a slot, so we don't
                -- start placing other blocks that we pick up into that
                -- slot instead.
                if ignoredLookup then
                    -- If the table still exists we definitely got our slot
                    -- from it (see conditional above). Remove it.
                    if turtle.getItemCount(slot) == 0 then
                        table.remove(ignoredLookup)
                    end
                    if #ignoredLookup == 0 then
                        ignoredLookup = nil
                    end
                    save()
                end
            end
        elseif placeTorches and lama.getY() % 8 == 0 then
            -- Place torches every couple of levels.
            turtle.select(torchSlot)
            turtle.placeDown()
        end
    end

    ignoredLookup = nil
    job = nil
    switchTo("goto_drop")
end)

--[[
    Gets enough fuel to move to the graveyard.
]]
:add("refuel_end", function()
    log:info("Getting my last rites. Fuel! I meant fuel.")
    private.sendMessage("state", "refuel_end")

    -- Generate the path to our final resting place: two up, n forward and one
    -- to the side (so future finishing turtles can pass us by).
    local x, y, z = lama.get()
    local path = {
        {x = x, y = y, z = z},
        {x = 0, y = 2, z = 0},
        {x = 0, y = 2, z = endSlot},
        {x = 1, y = 2, z = endSlot}
    }
    private.refuel(private.computeFuelNeeded(path))
    switchTo("clear_inventory")
end)

--[[
    Clear our inventory when we're done.
]]
:add("clear_inventory", function()
    log:info("Clearing out my inventory since I'm done with the world.")
    private.sendMessage("state", "clear_inventory")

    for slot = 1, 16 do
        private.drop(slot)
    end
    turtle.select(1)
    switchTo("goto_end")
end)

--[[
    Moves to *in front of* the slot where we'll shut down.
]]
:add("goto_end", function()
    log:info("Moving out of the way, I'm just useless junk anyway.")
    private.sendMessage("state", "goto_end")

    -- Player being invulnerable can block this, so we have to keep trying.
    repeat
        local x, y, z = lama.get()
        local path = private.generatePath(x, y, z, 0, 2, endSlot, "end")
    until lama.navigate(path, math.huge, true)
    switchTo("end")
end)

--[[
    Moves into the actual slot where we'll shut down and then die quietly.
]]
:add("end", function()
    log:info("That's it, I'm going to end it right here. It was a nice life.")
    private.sendMessage("state", "end")

    repeat until lama.moveto(1, 2, endSlot)
    startup.disable("jam")
    switchTo(nil)
end)

-------------------------------------------------------------------------------
-- Utility functions                                                         --
-------------------------------------------------------------------------------

-- Private namespace.
private = {}

--[[
    Asks the user for the size of the dig site and configures the floppy disk.

    This function never returns, it reboots the turtle after it has run.
]]
function private.setupDigSite()
    -- Label the disk if it hasn't been labeled yet.
    if not disk.getLabel(rsDiskSide) or disk.getLabel(rsDiskSide) == "" then
        disk.setLabel(rsDiskSide, "JAM Job State")
    end
    local diskPath = disk.getMountPath(rsDiskSide)

    -- Ask the user how big of a dig site he'd like to create.
    term.clear()
    term.setCursorPos(1, 1)
    print("  Welcome to JAM: Just another Miner!\n\n" ..
          "Please tell me how large an area you  \n" ..
          "want to mine. The area will always be \n" ..
          "squared. Use the arrow keys to adjust \n" ..
          "the size, then press [Enter].         \n")
    local _, y = term.getCursorPos()
    local format = {"  Size: %d (%d chunk, %d hole)\n",
                    "  Size: %d (%d chunks, %d holes)\n"}
    print("\n")
    write("[left/right: one, up/down: five steps]\n\n" ..
          "(Note: chunks refers to the number of \n" ..
          "affected ones, not the worked on area)")
    local size, radius, chunks, jobCount = 1
    repeat
        local rx, ry = term.getCursorPos()
        radius = size * 3
        chunks = math.ceil(radius / 8)
        chunks = chunks * chunks
        jobCount = private.computeJobCount(radius)
        term.setCursorPos(1, y)
        term.clearLine()
        write(string.format(size == 1 and format[1] or format[2],
                            radius, chunks, jobCount))
        -- For termination not f*cking up the shell.
        term.setCursorPos(rx, ry)

        local _, code = os.pullEvent("key")
        if code == keys.right then
            -- Let's bound the maximum dig site size to the area of loaded
            -- chunks around a single player...
            size = math.min(55, size + 2)
        elseif code == keys.left then
            size = math.max(1, size - 2)
        elseif code == keys.up then
            size = math.min(55, size + 10)
        elseif code == keys.down then
            size = math.max(1, size - 10)
        end
    until code == keys.enter

    local upOption = 0
    repeat
        term.clear()
        term.setCursorPos(1, 1)
        print("While making their way up out of the\n" ..
              "holes they dug, do you want your    \n" ..
              "turtles to:                         \n")
        if upOption == 0 then
            print(" > Fill the hole with ignored blocks!\n\n" ..
                  "   Place torches every now and then?\n\n" ..
                  "   Just dig as fast as they can?      \n")
        elseif upOption == 1 then
            print("   Fill the hole with ignored blocks?\n\n" ..
                  " > Place torches every now and then!\n\n" ..
                  "   Just dig as fast as they can?      \n")
        elseif upOption == 2 then
            print("   Fill the hole with ignored blocks?\n\n" ..
                  "   Place torches every now and then?\n\n" ..
                  " > Just dig as fast as they can!      \n")
        end
        print("Please select one with the arrow keys \n" ..
              "and press [Enter] to confirm.")
        local _, code = os.pullEvent("key")
        if code == keys.up then
            upOption = (upOption - 1) % 3
        elseif code == keys.down then
            upOption = (upOption + 1) % 3
        end
    until code == keys.enter
    local placeIgnored = upOption == 0
    local placeTorches = upOption == 1

    local haveIgnoreChest
    if not placeTorches then
        term.clear()
        term.setCursorPos(1, 1)
        print("Since the turtles won't need one of \n" ..
              "the chests for torches, you can     \n" ..
              "instead place blocks you want your  \n" ..
              "turtles to ignore in that chest.    \n" ..
              "This way you won't have to add them \n" ..
              "to each one individually. You'll    \n" ..
              "have to place exacly one stack of at\n" ..
              "least a size equal to the number of \n" ..
              "turtles you plan to use into the    \n" ..
              "torch chest.\n")
        write("Do you want to do this? [Y/n] > ")
        haveIgnoreChest = private.prompt()
    end

    term.clear()
    term.setCursorPos(1, 1)
    print("Please confirm your settings\n\n" ..
          "  Radius: " .. radius .. "\n" ..
          "    Affected chunks: " .. chunks .. "\n" ..
          "    Holes/Jobs: " .. jobCount     .. "\n" ..
          "  Place blocks: " .. tostring(placeIgnored) .. "\n" ..
          "  Place torches: " .. tostring(placeTorches) .. "\n" ..
          "  Blocks to ignore in chest: " .. tostring(haveIgnoreChest))
    write("\nIs this correct? [Y/n] > ")
    if not private.prompt() then
        return nil -- nil causes restart
    end

    -- Set up the disk so that it installs the script to any
    -- turtle that starts up while in front of it.
    term.clear()
    term.setCursorPos(1, 1)
    print("Writing initialization data to disk...")

    local install = {
        {bapil.resolveAPI("apis/bapil"),
            fs.combine(diskPath, "apis/bapil")},
        {bapil.resolveAPI("apis/lama"),
            fs.combine(diskPath, "apis/lama")},
        {bapil.resolveAPI("apis/logger"),
            fs.combine(diskPath, "apis/logger")},
        {bapil.resolveAPI("apis/stacktrace"),
            fs.combine(diskPath, "apis/stacktrace")},
        {bapil.resolveAPI("apis/startup"),
            fs.combine(diskPath, "apis/startup")},
        {bapil.resolveAPI("apis/state"),
            fs.combine(diskPath, "apis/state")},
        {shell.getRunningProgram(),
            fs.combine(diskPath, "programs/jam")}
    }
    fs.makeDir(fs.combine(diskPath, "apis"))
    fs.makeDir(fs.combine(diskPath, "programs"))
    for _, file in ipairs(install) do
        if fs.exists(file[1]) and not fs.isDir(file[1]) then
            -- Update / install.
            print(" > " .. file[2])
            if fs.exists(file[2]) then
                fs.delete(file[2])
            end
            fs.copy(file[1], file[2])
        elseif fs.exists(file[2]) and not fs.isDir(file[2]) then
            -- Already there.
            print(" > " .. file[2])
        elseif not file[3] then
            error("missing file " .. file[1])
        end
        os.sleep(0.1)
    end

    -- We write a startup file to the disk drive that will install our
    -- environment to any non-initialized turtles started up in front of it.
    local startupFile = fs.combine(diskPath, "startup")
    print(" > " .. startupFile)
    local file = fs.open(startupFile, "w")
    file.write(string.format([=[-- Automatically generated startup file.
-- Ignore anything that isn't a turtle.
if not turtle then
    return shell.run("/startup")
end

-- Ignore if we're on the wrong side. Otherwise get the mount path of the disk.
local diskSide = %q
if not disk.isPresent(diskSide) then
    return shell.run("/startup")
end
local diskPath = disk.getMountPath(diskSide)

-- Set label if necessary.
if os.getComputerLabel() == nil or os.getComputerLabel() == "" then
    os.setComputerLabel("JAM-" .. os.getComputerID())
end

-- Install APIs if they're not there yet. Update them if the file size differs.
local install = {
    {"apis/bapil",      fs.combine(diskPath, "apis/bapil")},
    {"apis/lama",       fs.combine(diskPath, "apis/lama")},
    {"apis/logger",     fs.combine(diskPath, "apis/logger")},
    {"apis/stacktrace", fs.combine(diskPath, "apis/stacktrace")},
    {"apis/startup",    fs.combine(diskPath, "apis/startup")},
    {"apis/state",      fs.combine(diskPath, "apis/state")}
}
fs.makeDir("apis")
for _, file in ipairs(install) do
    assert(fs.exists(file[2]) or file[3],
        "Bad disk, missing file: " .. file[2])
    if not fs.exists(file[1]) or not fs.isDir(file[1]) and
       fs.getSize(file[2]) ~= fs.getSize(file[1])
    then
        if fs.exists(file[1]) then
            fs.delete(file[1])
        end
        fs.copy(file[2], file[1])
    elseif fs.isDir(file[1]) then
        error("Bad installation, " .. file[1] .. " is a folder.")
    end
end

-- Install startup file if there isn't one, yet.
if not fs.exists("/startup") then
    local file = fs.open("/startup", "w")
    file.write([[-- Skip if we already ran.
if startup then
    return false
end

-- Install custom API loader.
os.loadAPI("apis/bapil")
bapil.hijackOSAPI()

-- Load stacktrace API and install tpcall as replacement for pcall.
assert(os.loadAPI("apis/stacktrace"))
_G.pcall = stacktrace.tpcall

-- Load startup API and perform startup.
assert(os.loadAPI("apis/startup"))
return startup.run()]])
    file.close()
end

-- Run local startup script.
if not dofile("/startup") then
    return false
end

assert(startup, "Bad installation, startup API not loaded automatically.")

-- Overwrite this program in case of updates (different file size).
local jamFile = fs.combine(diskPath, "programs/jam")
if not startup.isEnabled("jam") or
   fs.getSize(startup.scriptPath("jam")) ~= fs.getSize(jamFile)
then
    startup.remove("jam")
    startup.addFile("jam", 20, jamFile)
    startup.enable("jam")
    print("Done installing JAM, rebooting...")
    os.sleep(1)
    os.reboot()
end]=], rsDiskSide))
    file.close()

    return jobCount, placeTorches, placeIgnored, haveIgnoreChest
end

--[[
    This function asks the user to put blocks that should be ignored into the
    turtle's inventory and does some sanity checks on the found blocks.

    @param placeTorches whether we're to place torches or not.
    @return the number of block types to ignore.
]]
function private.setupIgnoredBlocks(placeTorches)
    -- If we come here a dig site has already been set up, so we just need to
    -- know which block types to ignore.
    term.clear()
    term.setCursorPos(1, 1)
    print("Please put one of each block type that\n" ..
          "you want to avoid into my inventory.  \n" ..
          "When done, press [Enter] to confirm.\n\n" ..
          "Oh, and you can place the blocks into \n" ..
          "any slot you want, I'll put them into \n" ..
          "the right ones myself \\o/          \n\n" ..
          "Recommended: Stone, Dirt and possibly \n" ..
          "Gravel or Sand (depends on the biome).\n" ..
          (placeIgnored and
          "You may also want to add Cobblestone, \n" ..
          "to allow placing it while moving up."
          or "" ))
    private.prompt({keys.enter}, {})
    print("OK, let me see...")

    -- Move stuff from anywhere in the inventory into the first slots, so that
    -- we have a continuous interval of occupied slots.
    local slot, free = 1
    while slot <= 16 do
        if turtle.getItemCount(slot) > 0 then
            turtle.select(slot)
            for i = 1, slot - 1 do
                if turtle.compareTo(i) then
                    if not turtle.transferTo(i) or
                       turtle.getItemCount(slot) > 0
                    then
                        term.clear()
                        term.setCursorPos(1, 1)
                        print("Well, I tried to reduce the redundant  \n" ..
                              "stuff you gave me into one pile, but I \n" ..
                              "failed horribly. Cut me some slack. ;) \n" ..
                              "Please try only giving one block per   \n" ..
                              "block type, m'kay?                     \n")
                        print("Press [Enter] to try again m(.,.)m")
                        private.prompt({keys.enter}, {})
                        return nil -- restarts the state
                    end
                    break
                end
            end
            if free and turtle.getItemCount(slot) > 0 then
                turtle.select(slot)
                turtle.transferTo(free)
                slot = free
                free = nil
            end
        end
        -- Might have become free while merging blocks.
        if turtle.getItemCount(slot) == 0 and free == nil then
            free = slot
        end
        slot = slot + 1
    end

    -- See how many blocks we have.
    local occupied = 0
    for slot = 1, 16 do
        if turtle.getItemCount(slot) > 0 then
            occupied = occupied + 1
        end
    end

    term.clear()
    term.setCursorPos(1, 1)
    if occupied == 0 then
        print("Woah, you want me to fetch, like,     \n" ..
              "everything? Even stone? That'll mean a\n" ..
              "lot of additional running back and    \n" ..
              "and forth, which is less efficient /o\\\n\n")
        write("Are you sure? [y/N] > ")
        if not private.prompt({keys.y}, {keys.n, keys.enter}) then
            return nil -- restarts the state
        end
        print("Oh boy... well, here goes nothing!")
    elseif occupied == 16 then
        print("You can't be serious, right? There's \n" ..
              "just no way this could possibly work.\n" ..
              "I need at least one free slot into   \n" ..
              "which I can put the stuff I dig up.  \n")
        print("Press [Enter] to try again -.-")
        private.prompt({keys.enter}, {})
        return nil -- restarts the state
    elseif occupied == 15 and placeTorches then
        print("Nice try, but this can't work in my  \n" ..
              "current configuration, since I need  \n" ..
              "one additional slot for the torches  \n" ..
              "I'm supposed to place. So I need some\n" ..
              "more room to store the stuff I dig up\n" ..
              "in. Meaning at least two free slots  \n" ..
              "in total. Can you do that for me?    \n")
        print("Press [Enter] to try again :/")
        private.prompt({keys.enter}, {})
        return nil -- restarts the state
    elseif occupied >= tempSlot or
           (placeTorches and occupied >= torchSlot)
    then
        print("Unless you messed with the code this \n" ..
              "should not happen: the inventory     \n" ..
              "range used for blocks to ignore      \n" ..
              "intersects with either the torch or  \n" ..
              "or our temporary working slot. You'll\n" ..
              "have to specify less than " ..
              math.min(tempSlot, torchSlot) ..
              " block   \n" ..
              "types. Press [Enter] to try again... \n")
        private.prompt({keys.enter}, {})
        return nil -- restarts the state
    elseif occupied > 6 then
        print("While this is technically a feasible \n" ..
              "configuration, I'd highly recommend  \n" ..
              "adding fewer blocks to ignore. The   \n" ..
              "more blocks I have to check the more \n" ..
              "often I have to go back to clear my  \n" ..
              "inventory, and the longer it takes   \n" ..
              "to check if I may dig up a block ^.- \n\n" ..
              "Is this really what you want?          ")
        write("[Y/n] > ")
        if not private.prompt() then
            return nil -- restarts the state
        end
        print("Well, if you say so... ley's do this!")
    else
        local agree = {
            "Sounds reasonable.",
            "Yeah, that seems about right.",
            "As you command, my master!",
            "I humbly obey.",
            "Wow, you've got taste.",
            "Off I go then!",
            "Here I go!",
            "Work, work."
        }
        print(agree[math.random(1, #agree)])
    end
    os.sleep(1.5)
    return occupied
end

--[[
    An automated version for getting the blocks we should ignore.
]]
function private.setupIgnoredBlocksFromIgnoreChest(placeTorches)
    lama.turn(torchSide)
    turtle.select(1)

    -- If we're resuming in here, it means we only have stuff we're supposed
    -- to ignore in our inventory. Dump it back and start over.
    for slot = 1, 16 do
        if turtle.getItemCount(slot) > 0 then
            turtle.select(slot)
            assert(turtle.drop(), "Chest with blocks to ignore is full!")
        end
    end

    -- Suck as often as we can. If there's more, silently ignore it.
    for slot = 1, 16 do
        if slot ~= tempSlot and not placeTorches or slot ~= torchSlot then
            turtle.select(slot)
            if not turtle.suck() then
                -- Stop if there's nothing else in there.
                break
            end
        end
    end
    -- Put everything except one item back.
    for slot = 1, 16 do
        if turtle.getItemCount(slot) > 0 then
            turtle.select(slot)
            turtle.drop(turtle.getItemCount(slot) - 1)
        else
            break
        end
    end

    -- Merge duplicates, compact the range and dump duplicates.
    for slot = 2, 16 do
        -- Ignore empty slots.
        if turtle.getItemCount(slot) > 0 then
            -- Compare to all preceding slots
            for otherSlot = 1, slot - 1 do
                if turtle.compareTo(otherSlot) then
                    -- Got one of the same kind, try to merge.
                    if not turtle.transferTo(otherSlot) or
                       turtle.getItemCount(slot) > 0
                    then
                        -- Could not merge (other stack already full) or still
                        -- have some left (other stack is now full and there's
                        -- still some left here). Drop the remainder.
                        assert(turtle.drop(),
                            "Chest with blocks to ignore is full!")
                    end
                end
            end
        end
        -- If there's still something in the slot we didn't find anything of
        -- the same kind in our inventory. Look for an empty slot at a lower
        -- index to get a continuous segment.
        if turtle.getItemCount(slot) > 0 then
            for otherSlot = 1, slot - 1 do
                if turtle.getItemCount(otherSlot) == 0 then
                    turtle.transferTo(otherSlot)
                    break
                end
            end
        end
    end

    -- Count the remaining number of ignored block types and return that.
    local count = 0
    for slot = 1, 16 do
        if turtle.getItemCount(slot) > 0 then
            count = count + 1
        else
            break
        end
    end
    return count
end

--[[
    Reads a single key input from the user and returns whether the prompt was
    confirmed or denied.

    @param yesKeys a single or multiple keys that indicate success.
    @param noKeys a single or multiple keys that indicate denial.
    @return whether the user accepted or denied the prompt.
]]
function private.prompt(yesKeys, noKeys)
    yesKeys = yesKeys or {keys.y, keys.enter}
    noKeys = noKeys or {keys.n}
    if not type(yesKeys) == "table" then
        yesKeys = {yesKeys}
    end
    if not type(noKeys) == "table" then
        noKeys = {noKeys}
    end
    local result
    term.setCursorBlink(true)
    repeat
        local _, code = os.pullEvent("key")
        for _, k in pairs(yesKeys) do
            if code == k then
                result = true
                break
            end
        end
        for _, k in pairs(noKeys) do
            if code == k then
                result = false
                break
            end
        end
    until result ~= nil
    term.setCursorBlink(false)
    return result
end

--[[
    Sends a message via WIFI if available.

    @param the message category, i.e. the type of the message.
    @param the actual message content.
]]
function private.sendMessage(category, message)
    if private.noModem then
        return
    elseif not private.modem then
        if peripheral.isPresent("right") and
           peripheral.getType("right") == "modem"
        then
            private.modem = peripheral.wrap("right")
        elseif peripheral.isPresent("left") and
               peripheral.getType("left") == "modem"
        then
            private.modem = peripheral.wrap("left")
        else
            -- Don't try again.
            private.noModem = true
            return
        end
    end
    local packet = {}
    packet.source = os.getComputerID()
    packet.sourceLabel = os.getComputerLabel()
    packet.category = category
    packet.message = message
    private.modem.transmit(sendChannel, 0, textutils.serialize(packet))
end

--[[
    Utility function to determine how many holes we can dig so that our spiral
    doesn't exceed the specified bounds.

    @param squareSize the size of the bounding square our dig operation has
        to fit into.
    @return the number of holes we will dig.
    @private
]]
function private.computeJobCount(squareSize)
    if squareSize < 0 then
        return 0
    end
    -- Subtract one for the center, then divide by six, because each following
    -- layer adds an additional six blocks.
    local spiralRadius = math.floor((squareSize - 1) / 6)
    -- Since we still have a square and we now know the number of layers, the
    -- number of holes is simply the length of one side squared.
    local sideLength = spiralRadius * 2 + 1
    return sideLength * sideLength
end

--[[
    Computes the actual x and y coordinates of the nth hole.

    @param n the number of the hole to compute the coordinates for.
    @return (x, y) being heightless the coordinates of the nth hole.
    @private
]]
function private.computeCoordinates(n)
    -- Adjust to zero indexed system.
    n = n - 1
    -- If we're at the origin we can return right away. In fact, we should,
    -- since we'd get a division by zero in the following...
    if n < 1 then
        return 0, 0
    end
    -- Compute the coordinates on a plain old rectangular spiral, first.
    local shell = math.floor((math.sqrt(n) + 1) / 2)
    local tmp = (2 * shell - 1); tmp = tmp * tmp
    local leg = math.floor((n - tmp) / (2 * shell))
    local element = (n - tmp) - (2 * shell * leg) - shell + 1
    local x, y
    if leg == 0 then
        x, y = shell, element
    elseif leg == 1 then
        x, y = -element, shell
    elseif leg == 2 then
        x, y = -shell, -element
    else
        x, y = element, -shell
    end
    -- Then map it to our knights move grid.
    return x * 2 - y, y * 2 + x
end

--[[
    Computes how much fuel is needed to travel along the specified path.

    @param path the path to compute the fuel requirement for.
    @return the required fuel to travel the path.
    @private
]]
function private.computeFuelNeeded(path)
    local function fuel(from, to)
        local dx = math.abs(to.x - from.x)
        local dy = math.abs(to.y - from.y)
        local dz = math.abs(to.z - from.z)
        return dx + dy + dz
    end
    local result = 0
    local previous = nil
    for _, current in ipairs(path) do
        if previous then
            result = result + fuel(previous, current)
        end
        previous = current
    end
    return result
end

--[[
    Computes a path leading from or to the docking station, from and to to the
    specified coordinates.

    When moving away from the docking station we move in the layer above it,
    when returning to it in the layer below it.
]]
function private.generatePath(sx, sy, sz, tx, ty, tz, target)
    if sx == tx and sz == tz then
        if sy == ty then
            return {}
        end
        return {{x = tx, y = ty, z = tz}}
    end
    local layer
    if target == "home" then
        layer = -1
    elseif target == "end" then
        layer = 2
    elseif target == "job" then
        layer = 1
    else
        error("'target' is invalid")
    end
    return {
        -- Start at the base station.
        {x = sx, y = sy,    z = sz},
        -- Move one up to the layer we use for moving away.
        {x = sx, y = layer, z = sz},
        -- Move to above the actual coordinates but on the same layer.
        {x = tx, y = layer, z = tz},
        -- Move down to where we want to go.
        {x = tx, y = ty,    z = tz}
    }
end

--[[
    Computes how much fuel we should stock up on for making sure we can safely
    travel to the specified dig site, dig it up, and come back.
]]
function private.computeExpeditionCost(job)
    local x, z = private.computeCoordinates(job)
    -- Start at home, move to the job location (layer enforced by function).
    local path = private.generatePath(0, 0, 0, x, -1, z, "job")
     -- Digging faaar down, worst case scenario.
    table.insert(path, {x = x, y = -255, z = z})
    -- Append our way back home (again, layer enforced by generatePath()).
    for _, point in ipairs(private.generatePath(x, -1, z, 0, 0, 0, "home")) do
        table.insert(path, point)
    end
    return private.computeFuelNeeded(path)
end

--[[
    Checks if all inventory slots are occupied.
]]
function private.isInventoryFull()
    for slot = 1, 16 do
        if turtle.getItemCount(slot) == 0 then
            return false
        end
    end
    return true
end

--[[
    Checks if a block in front of us should be ignored.
]]
function private.shouldIgnore(ignoreCount, detect, compare)
    if not detect() then
        return true
    end
    for slot = 1, ignoreCount do
        turtle.select(slot)
        if turtle.compare() then
            return slot
        end
    end
    return false
end

--[[
    Tries to empty out any inventories and then dig up the block.
]]
function private.suckAndDig(suck, dig)
    while not private.isInventoryFull() do
        if not suck() then
            return dig()
        end
    end
    return false
end

--[[
    Used to build our cache that we use to quickly look up which inventory
    slots contain ignored blocks, besides the reference slots.
]]
function private.rebuildIgnoreCache(ignoreCount, ignoredLookup, placeTorches)
    -- Build a look-up table of slots that also contain ignored items in case
    -- we dug up so many we had an overflow. This is used for quickly knowing
    -- which slot to select for placing ignored blocks while moving up.
    local count = 0
    for slot = ignoreCount + 1, 16 do
        if turtle.getItemCount(slot) > 0 and
           not placeTorches or slot ~= torchSlot
        then
            -- Got a candidate, compare it to all known ignored blocks.
            turtle.select(slot)
            for ignoreSlot = 1, ignoreCount do
                if turtle.compareTo(ignoreSlot) then
                    count = count + turtle.getItemCount(slot)
                    ignoredLookup = ignoredLookup or {}
                    table.insert(ignoredLookup, slot)
                    break
                end
            end
        end
    end
    -- Add the counts for the excess items in the stacks of the reference
    -- slots (we only need to keep one of these).
    for slot = 1, ignoreCount do
        count = count + (turtle.getItemCount(slot) - 1)
    end
    -- Get the number of blocks we need to place (our height delta to our
    -- starting level, which is -1).
    local placeIgnoredRequired = (math.abs(lama.getY()) - 1) - count
    if placeIgnoredRequired <= 0 then
        -- Don't save unnecessary stuff.
        placeIgnoredRequired = nil
    end

    return ignoredLookup, placeIgnoredRequired
end

--[[
    Drop the contents of the specified slot, keeping only a specific amount.
    This keeps trying to drop until it succeeds.
]]
function private.drop(slot, keep)
    keep = keep or 0
    local didLogFull = false -- Don't spam the log.
    while turtle.getItemCount(slot) > keep do
        lama.turn(dropSide)
        turtle.select(slot)
        if not turtle.drop(turtle.getItemCount(slot) - keep) then
            private.sendMessage("full", "The drop chest is full!")
            if not didLogFull then
                didLogFull = true
                log:warn("The drop chest is full! Waiting...")
            end
            os.sleep(5)
        end
    end
end

--[[
    Refuels the turtle to the specified fuel level. This keeps retrying until
    it succeeds.
]]
function private.refuel(needed)
    local didLogNoFuel = false -- Don't spam the log.
    while turtle.getFuelLevel() < needed do
        turtle.select(tempSlot)
        if turtle.getItemCount(tempSlot) == 0 then
            lama.turn(fuelSide)
            if not turtle.suck() then
                private.sendMessage("fuel", "We're all out fuel!")
                if not didLogNoFuel then
                    didLogNoFuel = true
                    log:warn("The fuel chest is empty! Waiting...")
                end
                os.sleep(5)
            end
        else
            -- Try to use whatever is in the slot as fuel. We want to make sure
            -- it really is fuel, so that for some weird reason we din't
            -- accidentally get something else in there (items flying around
            -- from randomly dying mobs for example) and put that into our
            -- fuel chest.
            local isFuel = true
            while turtle.getItemCount(tempSlot) > 0 and
                  turtle.getFuelLevel() < needed
            do
                if not turtle.refuel(1) then
                    isFuel = false
                    break
                end
            end
            if isFuel then
                -- It actually was fuel, try to put it back into the chest.
                turtle.drop()
            end
        end
    end

    -- Make sure we leave our temporary slot empty. We may put some fuel into
    -- the drop chest instead of back into the fuel chest by doing this (in
    -- case we were rebooted while refueling), but that's better than
    -- accidentally putting something that's not fuel into our fuel chest.
    private.drop(tempSlot)
end

--[[
    Restock on torches to get a full stack. This keeps retrying until it
    succeeds.
]]
function private.restockTorches()
    local didLogNoTorches = false -- Don't spam the log.
    while turtle.getItemSpace(torchSlot) > 0 do
        -- Select an empty slot because we cannot control how much we pull,
        -- then replenish our actual torch stack from that and drop the rest.
        turtle.select(tempSlot)
        -- Make sure our temp slot is empty or has torches in it.
        if turtle.getItemCount(tempSlot) > 0 and
           -- If we don't have any torches left we cannot be sure that whatever
           -- we have in our temp slot are torches, so we drop them. Otherwise
           -- we assume whatever is in our torch slot are guaranteed to be
           -- torches.
           (turtle.getItemCount(torchSlot) == 0 or
            not turtle.compareTo(torchSlot))
        then
            private.drop(tempSlot)
        end
        lama.turn(torchSide)
        -- At this point we can be sure that if there's something in our temp
        -- slot it's torches, so use them up first, before sucking up more.
        if turtle.getItemCount(tempSlot) > 0 or turtle.suck() then
            turtle.transferTo(torchSlot)
            -- Put back any surplus.
            turtle.drop()
        else
            private.sendMessage("torches", "We're all out of torches!")
            if not didLogNoTorches then
                didLogNoTorches = true
                log:warn("The torch chest is empty! Waiting...")
            end
            os.sleep(5)
        end
    end

    private.drop(tempSlot)
end

-------------------------------------------------------------------------------
-- Environment checking                                                      --
-------------------------------------------------------------------------------

assert(turtle, "JAM only works on turtles.")

assert(type(stateFile) == "string" and stateFile ~= "",
    "The setting 'stateFile' must be a non-empty string.")

assert(type(jobFile) == "string" and jobFile ~= "",
    "The setting 'jobFile' must be a non-empty string.")

assert(rawget(lama.side, dropSide),
    "The setting 'dropSide' must be a valid lama.side.")

assert(rawget(lama.side, fuelSide),
    "The setting 'fuelSide' must be a valid lama.side.")

assert(rawget(lama.side, torchSide),
    "The setting 'torchSide' must be a valid lama.side.")

assert(rawget(lama.side, diskSide),
    "The setting 'diskSide' must be a valid lama.side.")

assert(dropSide ~= fuelSide and fuelSide ~= diskSide and
       dropSide ~= diskSide and diskSide ~= torchSide and
       dropSide ~= torchSide and fuelSide ~= torchSide,
       "Duplicate side configuration detected. Make sure the side for each " ..
       "docking bay element (disk, drop, fuel and torch chest) is different.")

assert(type(rsDiskSide) == "string" and rsDiskSide ~= "",
    "'rsDiskSide' is invalid; did you mess with the code?")

-------------------------------------------------------------------------------
-- Initialization                                                            --
-------------------------------------------------------------------------------

-- Command line argument parsing.
local args = {...}
if args[1] == "reset" then
    if disk.isPresent(rsDiskSide) then
        local diskPath = disk.getMountPath(rsDiskSide)
        if #fs.list(diskPath) > 0 then
            term.clear()
            term.setCursorPos(1, 1)
            print("This will format the disk in the      \n" ..
                  "attached disk drive. All data will be \n" ..
                  "irretrievably lost.                 \n\n" ..
                  "Are you sure? [Y/n]")
            if private.prompt() then
                print("Formatting disk...")
                for _, file in pairs(fs.list(diskPath)) do
                    local path = fs.combine(diskPath, file)
                    print(" > " .. file .. (fs.isDir(path) and "/*" or ""))
                    fs.delete(path)
                    os.sleep(0.1)
                end
            else
                print("Aborting.")
                os.sleep(0.1) -- Eat key event.
                return false
            end
        end
    end

    program:reset()
    startup.disable("jam")
    return true
end

-- Run our program.
program:run()

-- If the program returns normally we've reached our final position, shut down.
os.shutdown()