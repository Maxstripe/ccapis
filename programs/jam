--[[
    JAM - Just Another Miner - 2013 Sangar

    This program is licensed under the MIT license.
    http://opensource.org/licenses/mit-license.php

    This program is intended to run on turtles working in a very specific
    environment, to collaboratively (optional) dig up blocks of interest in a
    designated area.

    This program is copied onto turtles thrown into that environment by the
    initialization program that comes with this program, which should be stored
    on a floppy disk in a drive part of the docking bay of the excavation area.
    See that program for more information on how to set up that docking bay.

    Turtles running this program will fetch a job ticket at the docking bay,
    being tracked on the floppy disk, and then execute an excavation at a
    location defined by that job ticket. The excavation will be performed as
    digging straight down to bedrock, then working back up while inspecting the
    four blocks facing the turtle and excavating them if they're not ignored.
    If at any point the turtle's inventory fills up (no more free slot), it
    will take a break to deliver the excavated materials, then resume its job.
    Once done with its job, instead of resuming after delivering its items, it
    will fetch a new ticket. It continues to do so until there are no more job
    tickets, at which point it will just move out of the way of turtles that
    are still working (if any).
]]

assert(os.loadAPI("apis/bapil"))
assert(os.loadAPI("apis/logger"))
assert(os.loadAPI("apis/startup"))
assert(os.loadAPI("apis/state"))
assert(os.loadAPI("apis/lama"))

-------------------------------------------------------------------------------
-- Semi-config (you normally won't want to touch these)                      --
-------------------------------------------------------------------------------

-- Whether to write our progress into a log file (each time the program changes
-- its state it would log that). This is primarily intended for debugging.
local writeLog = true

-- File in which to store current program state on the turtle, for resuming the
-- program after a reboot.
local stateFile = "/.jam-state"

-- The path to the file with camera signatures stored on the floppy disk. This
-- is prefixed with the mount path so it should be a relative path.
local diskSignaturesFile = "camera-signatures"

-- The path to the file on the disk drive which we use to track how many jobs
-- we have already assigned to turtles. Note that this will be prefixed with
-- the disk drives mount path, so it should be a relative path.
local jobFile = ".jobs"

-- Given the turtle is in it's native orientation, this is the side the chest
-- we drop stuff we found into.
local dropSide = lama.side.left

-- Given the turtle is in it's native orientation, this is the side the chest
-- we can get fuel from.
local fuelSide = lama.side.front

-- Given the turtle is in it's native orientation, this is the side the chest
-- we can get new torches from.
local torchSide = lama.side.right

-- Given the turtle is in it's native orientation, this is the side the floppy
-- disk drive we use to track job progress on is at.
local diskSide = lama.side.back

-------------------------------------------------------------------------------
-- Internal variables / constants                                            --
-------------------------------------------------------------------------------

-- Do not change the next two variables, lest they interfere with the interval
-- of blocks to ignore! They is just here to make the code more readable (no
-- magic numbers all over the place.)

-- A slot that we can assume to be empty, used for temporary stuff, in
-- particular when refueling or picking up torches.
local tempSlot = 15

-- The slot number in which we keep our torches.
local torchSlot = 16

-- Same as diskSide but using redstone.getSides() constants (for disk API).
local rsDiskSide = ({[lama.side.forward] = "front",
                     [lama.side.right] = "right",
                     [lama.side.back] = "back",
                     [lama.side.left] = "left"})[diskSide]

-- The name of the file in which the camera API stores its signatures. This is
-- only used if a camera is attached to the turtle.
local signaturesFile = (camera and camera.savePath and camera.savePath()) or
                       "/.camera-signatures"

-- The log we use. Use dummy logger if we're not supposed to log stuff.
local log = writeLog and logger.new("jam") or
            {info = function() end, warn = function() end}

-- Forward declaration of namespaces.
local private

-------------------------------------------------------------------------------
-- Program states                                                            --
-------------------------------------------------------------------------------

local program = state.new(stateFile)

--[[
    This state is purely used for interactively setting up a dig site. It asks
    the user a couple of questions, prepares the disk drive and then reboots
    into the actual dig loop. Once a dig site has been set up, it takes care
    of configuring the blocks that should be ignored, either via a camera or
    some blocks in the turtle's inventory.
]]
:add("setup", function()
    -- Make sure there's a disk drive behind us.
    assert(disk.isPresent(rsDiskSide),
        "Bad setup detected, no disk in disk drive found.")
    local diskPath = disk.getMountPath(rsDiskSide)

    -- Configure the turtle to use our local coordinate system.
    lama.set(0, 0, 0, lama.side.north)

    -- If there's no job file on the disk drive we're starting from scratch.
    local jobFile = fs.combine(diskPath, jobFile)
    if not fs.exists(jobFile) then
        placeTorches = private.setupDigSite()
        if placeTorches == nil then
            return -- nil is the abort signal, restart the state.
        end

        -- Check for chests.
        print("Checking for chests...")
        lama.turn(dropSide)
        assert(turtle.detect(),
            "Bad setup detected, no drop chest found.")
        lama.turn(fuelSide)
        assert(turtle.detect(),
            "Bad setup detected, no fuel chest found.")
        if placeTorches then
            lama.turn(torchSide)
            assert(turtle.detect(),
                "Bad setup detected, no torch chest found.")
        end
    end

    assert(not fs.isDir(jobFile), "Bad disk, folder at job file location.")

    lama.turn((diskSide + 2) % 4)
    switchTo("add_turtle")

    -- Finish initialization via disk startup. For example, this will install
    -- this program as an autorun script.
    os.reboot()
end)

--[[
    Given an existing dig site adds a new turtle to work on it.
]]
:add("add_turtle", function()
    -- Based on the context, ask for the blocks to ignore. If we're a camera
    -- turtle and there are signatures ask for the one to ignore, otherwise ask
    -- the user to place some blocks in our inventory.
    local diskPath = disk.getMountPath(rsDiskSide)
    local diskSignaturesFile = fs.combine(diskPath, diskSignaturesFile)
    if camera and camera.wrap() and
       fs.exists(diskSignaturesFile) and
       not fs.isDir(diskSignaturesFile)
    then
        -- We got a camera turtle and we have signatures, ask for signatures to
        -- ignore instead of overloading our inventory with blocks.
        ignoreSignatures = private.setupIgnoredSignatures()
    else
        -- Remember how many block types we're supposed to ignore.
        ignoreCount = private.setupIgnoredBlocks()
    end

    -- Drop any duplicates we have of the stuff we're supposed to ignore. Do
    -- not count those drops into our sampling (that we use to determine which
    -- ignored blocks come the most often, to make sure we compare to them
    -- first for an early exit and thus faster average comparison time).
    dontCountThat = true
    switchTo("goto_drop") -- Equivalent to drop, but more uniform flow.
end)

--[[
    Go back to the docking station to drop stuff we picked up.
]]
:add("goto_drop", function()
    log:info("Going home to deliver the goods.")
    turtle.select(1)
    -- Player being invulnerable can block this, so we have to keep trying.
    repeat
        local x, y, z = lama.get()
        local path = private.generatePath(x, y, z, 0, 0, 0, "home")
    until lama.navigate(path, math.huge, true)
    switchTo("drop")
end)

--[[
    Actually drop anything in our inventory that's surplus.
]]
:add("drop", function()
    if not dontCountThat then
        log:info("Dumping what I found!")
    end
    -- Drop any surplus of the blocks we're supposed to ignore. We may have
    -- gotten some when digging down.
    dropped = dropped or {}
    dropping = dropping or {}
    for slot = 1, ignoreCount do
        if turtle.getItemCount(slot) > 1 then
            -- Keep track of how many of that type we dropped. We use this to
            -- accumulate a growing sample size which allows us to sort the
            -- blocks we should ignore in a way so that the first blocks are
            -- more likely to be found, which should improve overall speed,
            -- since on average it takes less time to check each block come by.
            dropping[slot] = dropping[slot] or (turtle.getItemCount(slot) - 1)
            save()

            private.drop(slot, 1)

            -- Update after successful drop (we do this in two phases in case
            -- we're interrupted while dropping).
            if not dontCountThat then
                dropped[slot] = (dropped[slot] or 0) + dropping[slot]
            end
            dropping[slot] = nil
            save()
        end
    end

    -- If anything is left as marked being dropped we were shut down while
    -- dropping something, but the drop was actually successful. I'm not sure
    -- if this can really happen, but just to make sure...
    if not dontCountThat then
        for slot, count in pairs(dropping) do
            dropped[slot] = (dropped[slot] or 0) + dropping[slot]
        end
    end
    dropping = nil
    save()

    -- Drop all the items we actually found.
    droppingSurplus = droppingSurplus or {}
    for slot = ignoreCount + 1, 16 do
        if slot ~= torchSlot then
            -- It may be that we found so many blocks that we're actually
            -- supposed to ignore while digging down, that they spilled into
            -- another slot. Check this here.
            if turtle.getItemCount(slot) > 0 then
                turtle.select(slot)
                for ignoreSlot = 1, ignoreCount do
                    if turtle.compareTo(ignoreSlot) then
                        -- This is a block we're actually supposed to ignore!
                        droppingSurplus[slot] = droppingSurplus[slot] or
                            {ignoreSlot, turtle.getItemCount(slot)}
                        save()
                    end
                end
            end

            private.drop(slot)
        end
    end

    -- Save the accumulated surplus drops.
    if not dontCountThat then
        for _, entry in pairs(droppingSurplus) do
            local slot, count = entry[1], entry[2]
            dropped[slot] = (dropped[slot] or 0) + count
        end
    end
    droppingSurplus = nil
    dontCountThat = nil
    save()

    -- Continue with our current job, or get a new one if we don't have one.
    if job then
        switchTo("refuel_job")
    else
        switchTo("get_job")
    end
end)

--[[
    Tries to get a job, on success refuels and executes it, otherwise refuels
    to move to retirement position (out of the way of other turtles).
]]
:add("get_job", function()
    log:info("Looking for a new job.")
    lama.turn((diskSide + 2) % 4)

    -- Wait a bit to finish moving and connect to the disk drive.
    for i = 1, 20 do
        if disk.isPresent(rsDiskSide) then
            break
        end
        os.sleep(0.1)
    end

    assert(disk.isPresent(rsDiskSide),
        "Bad setup detected, no disk in disk drive behind me!")
    local diskPath = disk.getMountPath(rsDiskSide)
    local jobFile = fs.combine(diskPath, jobFile)

    local file = fs.open(jobFile, "r")
    local jobData = (file and textutils.unserialize(file.readAll())) or {}
    if file then file.close() end

    local nextJob = jobData.nextJob or 1
    if nextJob <= jobData.totalJobs then
        job = nextJob
        jobData.nextJob = job + 1
        placeTorches = placeTorches or jobData.placeTorches
        switchTo("refuel_job")
        log:info("Got one! Our new job ticket is #%d.", job)
    else
        endSlot = jobData.finished or 0
        jobData.finished = endSlot + 1
        switchTo("refuel_end")
        log:info("No more jobs. We're unemployed now.")
    end

    file = fs.open(jobFile, "w")
    file.write(textutils.serialize(jobData))
    file.close()
end)

--[[
    Gets enough fuel to get to and back from our job.
]]
:add("refuel_job", function()
    log:info("Getting enough fuel to make it to our job and back.")
    private.refuel(private.computeExpeditionCost(job))
    switchTo("restock_torches")
end)

--[[
    Refills our torch stack.
]]
:add("restock_torches", function()
    if placeTorches then
        log:info("Picking up some torches to bring light into the dark.")
        private.restockTorches()
    end
    switchTo("goto_job")
end)

--[[
    Moves the turtle to the top of the hole it should dig.
]]
:add("goto_job", function()
    local tx, tz = private.computeCoordinates(job)
    log:info("On my way to my workplace (%d, %d)!", tx, tz)
    turtle.select(1)
    -- Player being invulnerable can block this, so we have to keep trying.
    repeat
        local x, y, z = lama.get()
        local path = private.generatePath(x, y, z, tx, -1, tz, "job")
    until lama.navigate(path, math.huge, true)
    if resumeDigUp then
        switchTo("dig_up")
    else
        switchTo("dig_down")
    end
end)

--[[
    Digs a hole down until we hit bedrock, returns to drop stuff if full and
    returns to where we left off.
]]
:add("dig_down", function()
    turtle.select(1)
    if resumeDigDown then
        log:info("Going back to where I left of digging.")
        local x, y, z, f = unpack(resumeDigDown)
        repeat until lama.moveto(x, y, z, f, math.huge, true)
        resumeDigDown = nil
    end
    log:info("Looking for bedrock, can offer dancing skills.")
    repeat
        local brokeStuff = private.suckAndDig(turtle.suckDown, turtle.digDown)
        local couldMove, whyNot = lama.down(math.huge, true)
        if not couldMove and whyNot == lama.reason.invulnerable_entity then
            -- Gotta be the player entity, wait for it to move away.
            couldMove = true
        end
    until not brokeStuff and not couldMove
    if private.isInventoryFull() then
        resumeDigDown = {lama.get()}
        switchTo("goto_drop")
    else
        lama.turn(lama.side.north)
        switchTo("sort_ignore")
    end
end)

--[[
    Sorts the blocks we're supposed to ignore, if any, so that the most
    frequently encountered ones are at the lower inventory positions (for
    faster early exists when comparing).
]]
:add("sort_ignore", function()
    -- Early exit if there's nothing to sort.
    if ignoreCount <= 1 then
        switchTo("dig_up")
        return
    end

    log:info("Sorting blocks to ignore for improved lookup speed.")

    -- If we were interrupted while swapping items, restore our continuous list
    -- of blocks to ignore, then start over.
    while undo and #undo > 0 do
        local swap = table.remove(undo)
        turtle.select(swap[1])
        turtle.transferTo(swap[2])
        save()
    end
    undo = nil
    save()

    -- Computes the total number of samples we got of the block type in that
    -- slot (including ones already dropped and ignored).
    local function getCount(slot)
        local count = turtle.getItemCount(slot)
        return dropped and (count + (dropped[slot] or 0)) or count
    end
    -- Swaps to slots in the inventory, while keeping an undo log to restore
    -- our state if we're shut down while we're at it (to avoid getting our
    -- list with additional samples getting out of sync).
    local function swap(slotA, slotB)
        if getCount(slotA) == getCount(slotB) then
            return
        end
        -- Undo logic: we build a list of reverse inventory transfers. This is
        -- fine because even if a transfer wasn's successful across the reboot,
        -- the reverse operation simply won't do anything at all.
        local function pushUndo(a, b)
            undo = undo or {}
            table.insert(undo, {a, b})
            save()
        end
        turtle.select(slotA)
        pushUndo(tempSlot, slotA)
        turtle.transferTo(tempSlot)
        turtle.select(slotB)
        pushUndo(slotA, slotB)
        turtle.transferTo(slotA)
        turtle.select(tempSlot)
        pushUndo(slotB, slotA)
        turtle.transferTo(slotB)
        undo = nil
        if dropped then
            dropped[slotA], dropped[slotB] = dropped[slotB], dropped[slotA]
        end
        save()
    end

    -- Get the list of entry indices so that we can sort it based on the sample
    -- counts for the respective block types.
    local entries = {}
    for slot = 1, ignoreCount do
        table.insert(entries, slot)
    end
    table.sort(entries, function(a, b) return getCount(a) > getCount(b) end)

    -- Shuffle the inventory so that the block types with more samples are
    -- closer to the start of the inventory.
    for target = 1, #entries do
        local source = entries[target]
        swap(source, target)
        -- Update entry for the element we replaced (or rather: set its target
        -- entry to its new location).
        for i = 1, #entries do
            if entries[i] == target then
                entries[i] = source
                break
            end
        end
    end

    switchTo("dig_up")
end)

--[[
    Digs back up, picking up whatever isn't ignored. Returns home to drop
    stuff if inventory is full to resume where it we off.
]]
:add("dig_up", function()
    log:info("Digging back up, looking for valuables.")
    if ignoreSignatures then
        -- We got a camera to help us identify useless blocks.
        assert("not yet implemented")
        -- Only work in daylight, to make sure we get good signatures.
        while os.time() > 12 do
            os.sleep((24000 - os.time() * 1000) / 20)
        end
        -- TODO ...
    elseif ignoreCount then
        -- Old-school method of comparing a couple of constant blocks to the
        -- ones we come across to decide what to pick up and what not.
        if resumeDigUp then
            log:info("Getting back to where I took a break.")
            local x, y, z, f = unpack(resumeDigUp)
            repeat until lama.moveto(x, y, z, f, math.huge, true)
            resumeDigUp = nil
        end
        dropped = dropped or {}
        while lama.getY() < -1 do
            repeat
                -- See if we're ignoring that block. If we are, remember we found
                -- one more of that type (to increase our sample size), otherwise
                -- try to dig it out.
                local ignored = private.shouldIgnore(ignoreCount)
                if ignored then
                    if type(ignored) == "number" then
                        dropped[ignored] = (dropped[ignored] or 0) + 1
                        save()
                    end
                else
                    turtle.select(ignoreCount + 1)
                    private.suckAndDig(turtle.suck, turtle.dig)
                end
                if private.isInventoryFull() then
                    resumeDigUp = {lama.get()}
                    return switchTo("goto_drop")
                end
                lama.turnRight()
            until lama.getFacing() == lama.side.north
            -- Can only be blocked by a player, so we just wait.
            while not lama.up(math.huge, true) do end
            -- Place torches every couple of levels.
            if lama.getY() % 8 == 0 then
                turtle.select(torchSlot)
                turtle.placeDown()
            end
        end
    else
        assert("invalid program state")
    end

    job = nil
    switchTo("goto_drop")
end)

--[[
    Gets enough fuel to move to the graveyard.
]]
:add("refuel_end", function()
    log:info("Getting my last rites. Fuel! I meant fuel.")
    -- Generate the path to our final resting place: two up, n forward and one
    -- to the side (so future finishing turtles can pass us by).
    local x, y, z = lama.get()
    local path = {
        {x = x, y = y, z = z},
        {x = 0, y = 2, z = 0},
        {x = 0, y = 2, z = endSlot},
        {x = 1, y = 2, z = endSlot}
    }
    private.refuel(private.computeFuelNeeded(path))
    switchTo("clear_inventory")
end)

--[[
    Clear our inventory when we're done.
]]
:add("clear_inventory", function()
    log:info("Clearing out my inventory since I'm done with the world.")
    for slot = 1, 16 do
        private.drop(slot)
    end
    turtle.select(1)
    switchTo("goto_end")
end)

--[[
    Moves to *in front of* the slot where we'll shut down.
]]
:add("goto_end", function()
    log:info("Moving out of the way, I'm just useless junk anyway.")
    -- Player being invulnerable can block this, so we have to keep trying.
    repeat
        local x, y, z = lama.get()
        local path = private.generatePath(x, y, z, 0, 2, endSlot, "end")
    until lama.navigate(path, math.huge, true)
    switchTo("end")
end)

--[[
    Moves into the actual slot where we'll shut down and then die quietly.
]]
:add("end", function()
    log:info("That's it, I'm going to end it right here. It was a nice life.")
    repeat until lama.moveto(1, 2, endSlot)
    startup.disable("jam")
    switchTo(nil)
end)

-------------------------------------------------------------------------------
-- Utility functions                                                         --
-------------------------------------------------------------------------------

-- Private namespace.
private = {}

--[[
    Asks the user for the size of the dig site and configures the floppy disk.

    This function never returns, it reboots the turtle after it has run.
]]
function private.setupDigSite()
    -- Label the disk if it hasn't been labeled yet.
    if not disk.getLabel(rsDiskSide) or disk.getLabel(rsDiskSide) == "" then
        disk.setLabel(rsDiskSide, "JAM Job State")
    end
    local diskPath = disk.getMountPath(rsDiskSide)

    -- Ask the user how big of a dig site he'd like to create.
    term.clear()
    term.setCursorPos(1, 1)
    print("  Welcome to JAM: Just another Miner!\n\n" ..
          "Please tell me how large an area you  \n" ..
          "want to mine. The area will always be \n" ..
          "squared. Use the arrow keys to adjust \n" ..
          "the size, then press [Enter].         \n")
    local _, y = term.getCursorPos()
    local format = {"  Size: %d (%d chunk, %d hole)\n",
                    "  Size: %d (%d chunks, %d holes)\n"}
    print("\n")
    write("[left/right: one, up/down: five steps]\n\n" ..
          "(Note: chunks refers to the number of \n" ..
          "affected ones, not the worked on area)")
    local size, radius, chunks, jobCount = 1
    repeat
        local rx, ry = term.getCursorPos()
        radius = size * 3
        chunks = math.ceil(radius / 8)
        chunks = chunks * chunks
        jobCount = private.computeJobCount(radius)
        term.setCursorPos(1, y)
        term.clearLine()
        write(string.format(size == 1 and format[1] or format[2],
                            radius, chunks, jobCount))
        term.setCursorPos(rx, ry) -- For termination not f*cking up the shell.

        local _, code = os.pullEvent("key")
        if code == keys.right then
            -- Let's bound the maximum dig site size to the area of loaded
            -- chunks around a single player...
            size = math.min(55, size + 2)
        elseif code == keys.left then
            size = math.max(1, size - 2)
        elseif code == keys.up then
            size = math.min(55, size + 10)
        elseif code == keys.down then
            size = math.max(1, size - 10)
        end
    until code == keys.enter

    term.clear()
    term.setCursorPos(1, 1)
    write("Do you want torches to be placed in \n" ..
          "the dug holes? If so, turtles will  \n" ..
          "carry a stack of torches with them  \n" ..
          "and place them in the holes they dug\n" ..
          "while on their way back up.       \n\n" ..
          "Place torches? [Y/n] > ")
    local placeTorches = private.prompt()

    term.clear()
    term.setCursorPos(1, 1)
    print("Please confirm your settings\n\n" ..
          "  Radius: " .. radius .. "\n" ..
          "    Affected chunks: " .. chunks .. "\n" ..
          "    Holes/Jobs: " .. jobCount     .. "\n" ..
          "  Place torches: " .. tostring(placeTorches) .. "\n")
    write("Is this correct? [Y/n] > ")
    if not private.prompt() then
        return nil -- nil causes restart
    end

    -- Set up the disk so that it installs the script to any
    -- turtle that starts up while in front of it.
    term.clear()
    term.setCursorPos(1, 1)
    print("Writing initialization data to disk...")

    local install = {
        {bapil.resolveAPI("bapil"),
            fs.combine(diskPath, "apis/bapil")},
        {bapil.resolveAPI("camera"),
            fs.combine(diskPath, "apis/camera"), true},
        {bapil.resolveAPI("lama"),
            fs.combine(diskPath, "apis/lama")},
        {bapil.resolveAPI("logger"),
            fs.combine(diskPath, "apis/logger")},
        {bapil.resolveAPI("stacktrace"),
            fs.combine(diskPath, "apis/stacktrace")},
        {bapil.resolveAPI("startup"),
            fs.combine(diskPath, "apis/startup")},
        {bapil.resolveAPI("state"),
            fs.combine(diskPath, "apis/state")},
        {shell.getRunningProgram(),
            fs.combine(diskPath, "programs/jam")},
        {signaturesFile,
            fs.combine(diskPath, diskSignaturesFile), true}
    }
    fs.makeDir(fs.combine(diskPath, "apis"))
    fs.makeDir(fs.combine(diskPath, "programs"))
    for _, file in ipairs(install) do
        if fs.exists(file[1]) and not fs.isDir(file[1]) then
            -- Update / install.
            print(" > " .. file[2])
            fs.copy(file[1], file[2])
        elseif fs.exists(file[2]) and not fs.isDir(file[2]) then
            -- Already there.
            print(" > " .. file[2])
        elseif not file[3] then
            error("missing file " .. file[1])
        end
        os.sleep(0.1)
    end

    local jobFile = fs.combine(diskPath, jobFile)
    print(" > " .. jobFile)
    local file = fs.open(jobFile, "w")
    assert(file, "Could not open job file for writing.")
    file.write(textutils.serialize({totalJobs = jobCount,
                                    placeTorches = placeTorches}))
    file.close()

    -- We write a startup file to the disk drive that will install our
    -- environment to any non-initialized turtles started up in front of it.
    local startupFile = fs.combine(diskPath, "startup")
    print(" > " .. startupFile)
    local file = fs.open(startupFile, "w")
    file.write(string.format([=[-- Automatically generated startup file.
-- Ignore anything that isn't a turtle.
if not turtle then
    return shell.run("/startup")
end

-- Ignore if we're on the wrong side. Otherwise get the mount path of the disk.
local diskSide = %q
if not disk.isPresent(diskSide) then
    return shell.run("/startup")
end
local diskPath = disk.getMountPath(diskSide)

-- Set label if necessary.
if os.getComputerLabel() == nil or os.getComputerLabel() == "" then
    os.setComputerLabel("JAM-" .. os.getComputerID())
end

-- Install APIs if they're not there yet. Update them if the file size differs.
local install = {
    {"apis/bapil",      fs.combine(diskPath, "apis/bapil")},
    {"apis/camera",     fs.combine(diskPath, "apis/camera"), true},
    {"apis/lama",       fs.combine(diskPath, "apis/lama")},
    {"apis/logger",     fs.combine(diskPath, "apis/logger")},
    {"apis/stacktrace", fs.combine(diskPath, "apis/stacktrace")},
    {"apis/startup",    fs.combine(diskPath, "apis/startup")},
    {"apis/state",      fs.combine(diskPath, "apis/state")}
}
fs.makeDir("apis")
for _, file in ipairs(install) do
    assert(fs.exists(file[2]) or file[3],
        "Bad disk, missing file: " .. file[2])
    if not fs.exists(file[1]) or not fs.isDir(file[1]) and
       fs.getSize(file[2]) ~= fs.getSize(file[1])
    then
        if fs.exists(file[1]) then
            fs.delete(file[1])
        end
        fs.copy(file[2], file[1])
    elseif fs.isDir(file[1]) then
        error("Bad installation, " .. file[1] .. " is a folder.")
    end
end

-- Install startup file if there isn't one, yet.
if not fs.exists("/startup") then
    local file = fs.open("/startup", "w")
    file.write([[-- Skip if we already ran.
if startup then
    return false
end

-- Install custom API loader.
os.loadAPI("apis/bapil")
bapil.hijackOSAPI()

-- Load stacktrace API and install tpcall as replacement for pcall.
assert(os.loadAPI("apis/stacktrace"))
_G.pcall = stacktrace.tpcall

-- Load startup API and perform startup.
assert(os.loadAPI("apis/startup"))
return startup.run()]])
    file.close()
end

-- Run local startup script.
if not dofile("/startup") then
    return false
end

assert(startup, "Bad installation, startup API not loaded automatically.")

-- Copy signatures to the turtle if it's a camera turtle. We overwrite
-- signatures already on the turtle to make sure we have the ones we are
-- supposed to ignore.
if camera and camera.wrap() then
    local signaturesFile = %q
    local diskSignaturesFile = fs.combine(diskPath, %q)
    if fs.exists(diskSignaturesFile) then
        assert(not fs.exists(signaturesFile) or not fs.isDir(signaturesFile),
            "Bad installation, folder at location of signature file.")
        assert(not fs.isDir(diskSignaturesFile),
            "Bad disk, signature file is a folder.")
        if not fs.exists(signaturesFile) or
           fs.getSize(diskSignaturesFile) ~= fs.getSize(signaturesFile)
        then
            if fs.exists(signaturesFile) then
                fs.delete(signaturesFile)
            end
            fs.copy(diskSignaturesFile, signaturesFile)
        end
    end
end

-- Overwrite this program in case of updates (different file size).
local jamFile = fs.combine(diskPath, "programs/jam")
if not startup.isEnabled("jam") or
   fs.getSize(startup.scriptPath("jam")) ~= fs.getSize(jamFile)
then
    startup.remove("jam")
    startup.addFile("jam", 20, jamFile)
    startup.enable("jam")
    print("Done installing JAM, rebooting...")
    os.sleep(1)
    os.reboot()
end]=], rsDiskSide, signaturesFile, diskSignaturesFile))
    file.close()

    -- Reboot to initialize ourself from the disk.
    return placeTorches
end

--[[
    This function asks the user to put blocks that should be ignored into the
    turtle's inventory and does some sanity checks on the found blocks.

    @return the number of block types to ignore.
]]
function private.setupIgnoredBlocks()
    -- If we come here a dig site has already been set up, so we just need to
    -- know which block types to ignore.
    term.clear()
    term.setCursorPos(1, 1)
    print("Please insert one of each block type  \n" ..
          "that you want to avoid. When done,    \n" ..
          "press [Enter] to confirm.           \n\n" ..
          "Oh, and you can place the blocks      \n" ..
          "anywhere you want, I'll put them into \n" ..
          "the right slots myself \\o/           \n")
    private.prompt({keys.enter}, {})
    print("OK, let me see...")

    -- Move stuff from anywhere in the inventory into the first slots, so that
    -- we have a continuous interval of occupied slots.
    local slot, free = 1
    while slot <= 16 do
        if turtle.getItemCount(slot) > 0 then
            turtle.select(slot)
            for i = 1, slot - 1 do
                if turtle.compareTo(i) then
                    if not turtle.transferTo(i) or
                       turtle.getItemCount(slot) > 0
                    then
                        term.clear()
                        term.setCursorPos(1, 1)
                        print("Well, I tried to reduce the redundant  \n" ..
                              "stuff you gave me into one pile, but I \n" ..
                              "failed horribly. Cut me some slack. ;) \n" ..
                              "Please try only giving one block per   \n" ..
                              "block type, m'kay?                     \n")
                        print("Press [Enter] to try again m(.,.)m")
                        private.prompt({keys.enter}, {})
                        return -- restarts the state
                    end
                    break
                end
            end
            if free and turtle.getItemCount(slot) > 0 then
                turtle.select(slot)
                turtle.transferTo(free)
                slot = free
                free = nil
            end
        end
        -- Might have become free while merging blocks.
        if turtle.getItemCount(slot) == 0 and free == nil then
            free = slot
        end
        slot = slot + 1
    end

    -- See how many blocks we have.
    local occupied = 0
    for slot = 1, 16 do
        if turtle.getItemCount(slot) > 0 then
            occupied = occupied + 1
        end
    end

    term.clear()
    term.setCursorPos(1, 1)
    if occupied == 0 then
        print("Woah, you want me to fetch, like,     \n" ..
              "everything? Even cobblestone? That'll \n" ..
              "mean a lot of additional running back \n" ..
              "and forth, which is less efficient /o\\\n\n")
        write("Are you sure? [y/N] > ")
        if not private.prompt({keys.y}, {keys.n, keys.enter}) then
            return -- restarts the state
        end
        print("Oh boy... well, here goes nothing!")
    elseif occupied == 16 then
        print("You can't be serious, right? There's \n" ..
              "just no way this could possibly work.\n" ..
              "I need at least one free slot into   \n" ..
              "which I can put the stuff I dig up.  \n")
        print("Press [Enter] to try again -.-")
        private.prompt({keys.enter}, {})
        return -- restarts the state
    elseif occupied == 15 and placeTorches then
        print("Nice try, but this can't work in my  \n" ..
              "current configuration, since I need  \n" ..
              "one additional slot for the torches  \n" ..
              "I'm supposed to place. So I need some\n" ..
              "more room to store the stuff I dig up\n" ..
              "in. Meaning at least two free slots  \n" ..
              "in total. Can you do that for me?    \n")
        print("Press [Enter] to try again :/")
        private.prompt({keys.enter}, {})
        return -- restarts the state
    elseif occupied >= tempSlot or occupied >= torchSlot then
        print("Unless you messed with the code this \n" ..
              "should not happen: the inventory     \n" ..
              "range used for blocks to ignore      \n" ..
              "intersects with either the torch or  \n" ..
              "or our temporary working slot. You'll\n" ..
              "have to specify less than " ..
              math.min(tempSlot, torchSlot) ..
              " block   \n" ..
              "types. Press [Enter] to try again... \n")
        private.prompt({keys.enter}, {})
        return -- restarts the state
    elseif occupied > 6 then
        print("While this is technically a feasible \n" ..
              "configuration, I'd highly recommend  \n" ..
              "adding fewer blocks to ignore. The   \n" ..
              "more blocks I have to check the more \n" ..
              "often I have to go back to clear my  \n" ..
              "inventory, and the longer it takes   \n" ..
              "to check if I may dig up a block ^.- \n\n" ..
              "Is this really what you want?          ")
        write("[Y/n] > ")
        if not private.prompt() then
            return -- restarts the state
        end
        print("Well, if you say so... ley's do this!")
    else
        local agree = {
            "Sounds reasonable.",
            "Yeah, that seems about right.",
            "As you command, my master!",
            "I humbly obey.",
            "Wow, you've got taste.",
            "Off I go then!",
            "Here I go!",
            "Work, work."
        }
        print(agree[math.random(1, #agree)])
    end
    os.sleep(2.5)
    return occupied
end

--[[
    This function asks the user for the names of the block types to ignore. It
    validates the input against the list of known signatures.

    @return a table with the names of the signatures to ignore.
]]
function private.setupIgnoredSignatures()
    assert(false, "not yet implemented")
end

--[[
    Reads a single key input from the user and returns whether the prompt was
    confirmed or denied.

    @param yesKeys a single or multiple keys that indicate success.
    @param noKeys a single or multiple keys that indicate denial.
    @return whether the user accepted or denied the prompt.
]]
function private.prompt(yesKeys, noKeys)
    yesKeys = yesKeys or {keys.y, keys.enter}
    noKeys = noKeys or {keys.n}
    if not type(yesKeys) == "table" then
        yesKeys = {yesKeys}
    end
    if not type(noKeys) == "table" then
        noKeys = {noKeys}
    end
    local result
    term.setCursorBlink(true)
    repeat
        local _, code = os.pullEvent("key")
        for _, k in pairs(yesKeys) do
            if code == k then
                result = true
                break
            end
        end
        for _, k in pairs(noKeys) do
            if code == k then
                result = false
                break
            end
        end
    until result ~= nil
    term.setCursorBlink(false)
    return result
end

--[[
    Sends a message via WIFI if available.

    @param the message category, i.e. the type of the message.
    @param the actual message content.
]]
function private.sendMessage(category, message)
    if not private.modem then
        return
    end
    local packet = {}
    packet.source = os.getComputerID()
    packet.sourceLabel = os.getComputerLabel()
    packet.category = category
    packet.message = message
    private.modem.transmit(sendChannel, 0, textutils.serialize(packet))
end

--[[
    Utility function to determine how many holes we can dig so that our spiral
    doesn't exceed the specified bounds.

    @param squareSize the size of the bounding square our dig operation has
        to fit into.
    @return the number of holes we will dig.
    @private
]]
function private.computeJobCount(squareSize)
    if squareSize < 0 then
        return 0
    end
    -- Subtract one for the center, then divide by six, because each following
    -- layer adds an additional six blocks.
    local spiralRadius = math.floor((squareSize - 1) / 6)
    -- Since we still have a square and we now know the number of layers, the
    -- number of holes is simply the length of one side squared.
    local sideLength = spiralRadius * 2 + 1
    return sideLength * sideLength
end

--[[
    Computes the actual x and y coordinates of the nth hole.

    @param n the number of the hole to compute the coordinates for.
    @return (x, y) being heightless the coordinates of the nth hole.
    @private
]]
function private.computeCoordinates(n)
    -- Adjust to zero indexed system.
    n = n - 1
    -- If we're at the origin we can return right away. In fact, we should,
    -- since we'd get a division by zero in the following...
    if n < 1 then
        return 0, 0
    end
    -- Compute the coordinates on a plain old rectangular spiral, first.
    local shell = math.floor((math.sqrt(n) + 1) / 2)
    local tmp = (2 * shell - 1); tmp = tmp * tmp
    local leg = math.floor((n - tmp) / (2 * shell))
    local element = (n - tmp) - (2 * shell * leg) - shell + 1
    local x, y
    if leg == 0 then
        x, y = shell, element
    elseif leg == 1 then
        x, y = -element, shell
    elseif leg == 2 then
        x, y = -shell, -element
    else
        x, y = element, -shell
    end
    -- Then map it to our knights move grid.
    return x * 2 - y, y * 2 + x
end

--[[
    Computes how much fuel is needed to travel along the specified path.

    @param path the path to compute the fuel requirement for.
    @return the required fuel to travel the path.
    @private
]]
function private.computeFuelNeeded(path)
    local function fuel(from, to)
        local dx = math.abs(to.x - from.x)
        local dy = math.abs(to.y - from.y)
        local dz = math.abs(to.z - from.z)
        return dx + dy + dz
    end
    local result = 0
    local previous = nil
    for _, current in ipairs(path) do
        if previous then
            result = result + fuel(previous, current)
        end
        previous = current
    end
    return result
end

--[[
    Computes a path leading from or to the docking station, from and to to the
    specified coordinates.

    When moving away from the docking station we move in the layer above it,
    when returning to it in the layer below it.
]]
function private.generatePath(sx, sy, sz, tx, ty, tz, target)
    if sx == tx and sz == tz then
        if sy == ty then
            return {}
        end
        return {{x = tx, y = ty, z = tz}}
    end
    local layer
    if target == "home" then
        layer = -1
    elseif target == "end" then
        layer = 2
    elseif target == "job" then
        layer = 1
    else
        error("'target' is invalid")
    end
    return {
        -- Start at the base station.
        {x = sx, y = sy,    z = sz},
        -- Move one up to the layer we use for moving away.
        {x = sx, y = layer, z = sz},
        -- Move to above the actual coordinates but on the same layer.
        {x = tx, y = layer, z = tz},
        -- Move down to where we want to go.
        {x = tx, y = ty,    z = tz}
    }
end

--[[
    Computes how much fuel we should stock up on for making sure we can safely
    travel to the specified dig site, dig it up, and come back.
]]
function private.computeExpeditionCost(job)
    local x, z = private.computeCoordinates(job)
    -- Start at home, move to the job location (layer enforced by function).
    local path = private.generatePath(0, 0, 0, x, -1, z, "job")
     -- Digging faaar down, worst case scenario.
    table.insert(path, {x = x, y = -255, z = z})
    -- Append our way back home (again, layer enforced by generatePath()).
    for _, point in ipairs(private.generatePath(x, -1, z, 0, 0, 0, "home")) do
        table.insert(path, point)
    end
    return private.computeFuelNeeded(path)
end

--[[
    Checks if all inventory slots are occupied.
]]
function private.isInventoryFull()
    local count = 0
    for slot = 1, 16 do
        if turtle.getItemCount(slot) > 0 then
            count = count + 1
        end
    end
    return count == 16
end

--[[
    Checks if a block in front of us should be ignored.
]]
function private.shouldIgnore(ignoreCount)
    if not turtle.detect() then
        return true
    end
    for slot = 1, ignoreCount do
        turtle.select(slot)
        if turtle.compare() then
            return slot
        end
    end
    return false
end

--[[
    Tries to empty out any inventories and then dig up the block.
]]
function private.suckAndDig(suck, dig)
    while not private.isInventoryFull() do
        if not suck() then
            return dig()
        end
    end
    return false
end

--[[
    Drop the contents of the specified slot, keeping only a specific amount.
    This keeps trying to drop until it succeeds.
]]
function private.drop(slot, keep)
    keep = keep or 0
    local didLogFull = false -- Don't spam the log.
    while turtle.getItemCount(slot) > keep do
        lama.turn(dropSide)
        turtle.select(slot)
        if not turtle.drop(turtle.getItemCount(slot) - keep) then
            private.sendMessage("full", "The drop chest is full!")
            if not didLogFull then
                didLogFull = true
                log:warn("The drop chest is full! Waiting...")
            end
            os.sleep(5)
        end
    end
end

--[[
    Refuels the turtle to the specified fuel level. This keeps retrying until
    it succeeds.
]]
function private.refuel(needed)
    local didLogNoFuel = false -- Don't spam the log.
    while turtle.getFuelLevel() < needed do
        turtle.select(tempSlot)
        if turtle.getItemCount(tempSlot) == 0 then
            lama.turn(fuelSide)
            if not turtle.suck() then
                private.sendMessage("fuel", "We're all out fuel!")
                if not didLogNoFuel then
                    didLogNoFuel = true
                    log:warn("The fuel chest is empty! Waiting...")
                end
                os.sleep(5)
            end
        else
            -- Try to use whatever is in the slot as fuel. We want to make sure
            -- it really is fuel, so that for some weird reason we din't
            -- accidentally get something else in there (items flying around
            -- from randomly dying mobs for example) and put that into our
            -- fuel chest.
            local isFuel = true
            while turtle.getItemCount(tempSlot) > 0 and
                  turtle.getFuelLevel() < needed
            do
                if not turtle.refuel(1) then
                    isFuel = false
                    break
                end
            end
            if isFuel then
                -- It actually was fuel, try to put it back into the chest.
                turtle.drop()
            end
        end
    end

    -- Make sure we leave our temporary slot empty. We may put some fuel into
    -- the drop chest instead of back into the fuel chest by doing this (in
    -- case we were rebooted while refueling), but that's better than
    -- accidentally putting something that's not fuel into our fuel chest.
    private.drop(tempSlot)
end

--[[
    Restock on torches to get a full stack. This keeps retrying until it
    succeeds.
]]
function private.restockTorches()
    local didLogNoTorches = false -- Don't spam the log.
    while turtle.getItemSpace(torchSlot) > 0 do
        -- Select an empty slot because we cannot control how much we pull,
        -- then replenish our actual torch stack from that and drop the rest.
        turtle.select(tempSlot)
        -- Make sure our temp slot is empty or has torches in it.
        if turtle.getItemCount(tempSlot) > 0 and
           -- If we don't have any torches left we cannot be sure that whatever
           -- we have in our temp slot are torches, so we drop them. Otherwise
           -- we assume whatever is in our torch slot are guaranteed to be
           -- torches.
           (turtle.getItemCount(torchSlot) == 0 or
            not turtle.compareTo(torchSlot))
        then
            private.drop(tempSlot)
        end
        lama.turn(torchSide)
        -- At this point we can be sure that if there's something in our temp
        -- slot it's torches, so use them up first, before sucking up more.
        if turtle.getItemCount(tempSlot) > 0 or turtle.suck() then
            turtle.transferTo(torchSlot)
            -- Put back any surplus.
            turtle.drop()
        else
            private.sendMessage("toches", "We're all out of torches!")
            if not didLogNoTorches then
                didLogNoTorches = true
                log:warn("The torch chest is empty! Waiting...")
            end
            os.sleep(5)
        end
    end

    private.drop(tempSlot)
end

-------------------------------------------------------------------------------
-- Environment checking                                                      --
-------------------------------------------------------------------------------

assert(turtle, "JAM only works on turtles.")

assert(type(stateFile) == "string" and stateFile ~= "",
    "The setting 'stateFile' must be a non-empty string.")

assert(type(diskSignaturesFile) == "string" and diskSignaturesFile ~= "",
    "The setting 'diskSignaturesFile' must be a non-empty string.")

assert(type(jobFile) == "string" and jobFile ~= "",
    "The setting 'jobFile' must be a non-empty string.")

assert(rawget(lama.side, dropSide),
    "The setting 'dropSide' must be a valid lama.side.")

assert(rawget(lama.side, fuelSide),
    "The setting 'fuelSide' must be a valid lama.side.")

assert(rawget(lama.side, torchSide),
    "The setting 'torchSide' must be a valid lama.side.")

assert(rawget(lama.side, diskSide),
    "The setting 'diskSide' must be a valid lama.side.")

assert(dropSide ~= fuelSide and fuelSide ~= diskSide and
       dropSide ~= diskSide and diskSide ~= torchSide and
       dropSide ~= torchSide and fuelSide ~= torchSide,
       "Duplicate side configuration detected. Make sure the side for each " ..
       "docking bay element (disk, drop, fuel and torch chest) is different.")

assert(type(rsDiskSide) == "string" and rsDiskSide ~= "",
    "'rsDiskSide' is invalid; did you mess with the code?")

-------------------------------------------------------------------------------
-- Initialization                                                            --
-------------------------------------------------------------------------------

-- Command line argument parsing.
local args = {...}
if args[1] == "reset" then
    if disk.isPresent(rsDiskSide) then
        local diskPath = disk.getMountPath(rsDiskSide)
        if #fs.list(diskPath) > 0 then
            term.clear()
            term.setCursorPos(1, 1)
            print("This will format the disk in the      \n" ..
                  "attached disk drive. All data will be \n" ..
                  "irretrievably lost.                 \n\n" ..
                  "Are you sure? [Y/n]")
            if private.prompt() then
                print("Formatting disk...")
                for _, file in pairs(fs.list(diskPath)) do
                    local path = fs.combine(diskPath, file)
                    print(" > " .. file .. (fs.isDir(path) and "/*" or ""))
                    fs.delete(path)
                    os.sleep(0.1)
                end
            else
                print("Aborting.")
                os.sleep(0.1) -- Eat key event.
                return false
            end
        end
    end

    program:reset()
    startup.disable("jam")
    return true
end

-- Run our program.
program:run()

-- If the program returns normally we've reached our final position, shut down.
os.shutdown()